{"version":3,"sources":["../../../src/utils/FileHandler.ts"],"sourceRoot":"./","sourcesContent":["// file: src/utils/FileHandler.ts\r\n\r\nimport fs from 'fs-extra';\r\nimport * as lockfile from 'lockfile';\r\n\r\nimport { _isProd_, _isDev_, _isDebug_ } from '../dev/EnvConf.js';\r\n\r\nimport { storageService } from '../services';\r\n\r\nexport interface FileHandlerOptions {\r\n    lockFileOptions: lockfile.Options;\r\n}\r\n\r\n// Purpose: \r\n// - We are attempting to read and write to files owned by vscode, so\r\n// - we need to be cautious about how we handle these files.\r\n\r\n/**\r\n * A class that provides file handling with a lock file to prevent concurrent\r\n * read/write operations on the same file.\r\n * \r\n * @note This class is a singleton and must be initialized before use.\r\n * @note Not optimized for multiple sequential reads or writes. Use with caution.\r\n * @note The lockfile library gracefully handles lock files on process terminations.\r\n * \r\n * @example Initialize the FileHandler singleton instance:\r\n * ```typescript\r\n * const fileHandler = FileHandler.initOnce({\r\n *    lockFileOptions: { retries: 5, retryWait: 100 }\r\n * });\r\n * ```\r\n */\r\nexport class FileHandler {\r\n    /** When true, returned errors include stack trace */\r\n    public static _debug: boolean = false;\r\n\r\n    private static _instance: FileHandler | null = null;\r\n\r\n    /** Turns true once initOnce() is called with init options */\r\n    private static _initialized: boolean = false;\r\n\r\n    /** The options to use when acquiring the lock. */\r\n    private _lockFileOptions: lockfile.Options;\r\n\r\n    /** Private constructor - invoked via initOnce() */\r\n    private constructor(options: FileHandlerOptions) {\r\n        this._lockFileOptions = options.lockFileOptions;\r\n    }\r\n\r\n    /**\r\n     * Initializes the FileHandler singleton instance.\r\n     * @param options The options to use for the FileHandler.\r\n     * @returns The initialized FileHandler instance.\r\n     * @throws Error if the FileHandler is already initialized.\r\n     * @note This method must be called before using the FileHandler.\r\n     */\r\n    public static initOnce(options: FileHandlerOptions): FileHandler | never {\r\n        if (FileHandler._initialized || FileHandler._instance !== null) {\r\n            throw FileHandler.error('instance', 'init', new Error('Already initialized, cannot reinitialize'));\r\n        }\r\n        FileHandler._instance = new FileHandler(options);\r\n        FileHandler._initialized = true;\r\n        return FileHandler.instance;\r\n    }\r\n\r\n    /**\r\n     * Returns the singleton instance of the FileHandler.\r\n     * @returns The FileHandler instance.\r\n     * @throws Error if the FileHandler is not initialized.\r\n     * @note Call init() attempting to access the FileHandler instance.\r\n     */\r\n    public static get instance(): FileHandler | never {\r\n        if (!FileHandler._initialized || FileHandler._instance === null) {\r\n            throw FileHandler.error('instance', 'get', new Error('Not yet initialized, call init() first'));\r\n        }\r\n        return FileHandler._instance;\r\n    }\r\n\r\n    /**\r\n     * Acquires a lock on a file.\r\n     * @returns A promise that resolves when the lock is acquired.\r\n     */\r\n    private async acquireLock(filePath: string): Promise<void> {\r\n        const _lockFilePath = FileHandler.getLockFilePath(filePath);\r\n        return new Promise((resolve, reject) => {\r\n            lockfile.lock(_lockFilePath, this._lockFileOptions, (err) => {\r\n                if (err) {\r\n                    reject(FileHandler.error('lock', `acquire\\n\\tfile: ${filePath}`, err));\r\n                }\r\n                else {\r\n                    resolve();\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases a lock on a file.\r\n     * @returns A promise that resolves when the lock is released.\r\n     */\r\n    private async releaseLock(filePath: string): Promise<void> {\r\n        const _lockFilePath = FileHandler.getLockFilePath(filePath);\r\n        return new Promise((resolve, reject) => {\r\n            lockfile.unlock(_lockFilePath, (err) => {\r\n                if (err) {\r\n                    reject(FileHandler.error('lock', `release\\n\\tfile: ${filePath}`, err));\r\n                }\r\n                else {\r\n                    resolve();\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Writes data to a file (with caution - using a lock file).\r\n     * @param filePath The path to the file to write.\r\n     * @param data The data to write to the file.\r\n     * @param encoding Default is 'utf8'.\r\n     * @throws Error if the file could not be written, or if the lock could not be acquired or released.\r\n     * @note Not optimized for multiple sequential writes. Use with caution.\r\n     */\r\n    async cautiousWriteFile(filePath: string, data: string, encoding: BufferEncoding = 'utf8'): Promise<void> {\r\n        try {\r\n            await this.acquireLock(filePath);\r\n            await fs.writeFile(filePath, data, encoding);\r\n        } catch (err) {\r\n            throw FileHandler.error('file', `write\\n\\tfile: ${filePath}`, err as Error);\r\n        } finally {\r\n            await this.releaseLock(filePath);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads data from a file (with caution - using a lock file)\r\n     * @param filePath The path to the file to read.\r\n     * @param encoding Default is 'utf8'.\r\n     * @returns Returns the file content as a string.\r\n     * @throws Error if the file could not be read, or if the lock could not be acquired or released.\r\n     * @note Not optimized for multiple sequential reads. Use with caution.\r\n     */\r\n    async cautiousReadFile(filePath: string, encoding: BufferEncoding = 'utf8'): Promise<string> {\r\n        try {\r\n            await this.acquireLock(filePath);\r\n            return await fs.readFile(filePath, encoding);\r\n        } catch (err) {\r\n            throw FileHandler.error('file', `read\\n\\tfile: ${filePath}`, err as Error);\r\n        } finally {\r\n            await this.releaseLock(filePath);\r\n        }\r\n    }\r\n\r\n    private static getLockFilePath(filePath: string): string {\r\n        // Simple strategy: append \".lock\" to the original file path. Adjust as needed.\r\n        return `${filePath}.lock`;\r\n    }\r\n\r\n    private static error(duringOp: string, failedTo: string, error: Error): Error {\r\n        let message = `[FileHandler] Error: During ${duringOp} failed to ${failedTo}\\n\\tError: '${error.message}'`;\r\n\r\n        if (_isDebug_) {\r\n            message += `\\n\\tStack: ${error.stack}`;\r\n        }\r\n\r\n        return new Error(`[FileHandler] Error: During ${duringOp} failed to ${failedTo}\\n\\t'${error.message}'`);\r\n    }\r\n}\r\n"],"names":["FileHandler","_debug","_instance","_initialized","_lockFileOptions","options","lockFileOptions","initOnce","error","Error","instance","acquireLock","filePath","_lockFilePath","getLockFilePath","Promise","resolve","reject","lockfile","lock","err","releaseLock","unlock","cautiousWriteFile","data","encoding","fs","writeFile","cautiousReadFile","readFile","duringOp","failedTo","message","_isDebug_","stack"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}